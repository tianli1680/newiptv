name: Process M3U Playlist

on:
  workflow_dispatch:
  schedule:
    - cron: '0 */2 * * *'  # 每天自动运行一次

jobs:
  process-playlist:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # 添加仓库写入权限
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Process M3U playlists
      run: |
        python << 'EOF'
        import re
        import urllib.request
        import urllib.parse
        import os
        
        # 主m3u文件URL
        main_m3u_url = "https://live.ottiptv.cc/iptv.m3u?userid=8137863657&sign=2c8d82c9f17f480726d4770be9d0fb33fd0fcb31e1024448c36663605ea6a3f99e5bd467b68c287e3f0c07f85b95a188139aa3f19e227e251dc707bce0ededaab73ceeaddf6195&auth_token=54741b289e946919fc1c34ca88db58a4"
        
        # 额外m3u文件URLs
        extra_urls = {
            'huya.m3u': 'https://raw.githubusercontent.com/mursor1985/LIVE/refs/heads/main/huyayqk.m3u',
            'douyu.m3u': 'https://raw.githubusercontent.com/mursor1985/LIVE/refs/heads/main/douyuyqk.m3u',
            'yylunbo.m3u': 'https://raw.githubusercontent.com/mursor1985/LIVE/refs/heads/main/yylunbo.m3u'
        }
        
        # 新增URL链接 - 分别对应不同的分组
        additional_urls = {
            'iqiyi.m3u': 'https://raw.githubusercontent.com/tianli1680/rihou/refs/heads/main/iqiyi.m3u',
            'migu.m3u': 'https://raw.githubusercontent.com/tianli1680/rihou/refs/heads/main/migu.m3u',
            'iqiyi1.m3u': 'https://raw.githubusercontent.com/tianli1680/rihou/refs/heads/main/iqiyi1.m3u'  # 新增的iqiyi1链接
        }
        
        # 新增链接 - 用于提取央视和卫视频道
        migu_video_url = "https://raw.githubusercontent.com/tianli1680/migu_video/main/interface.txt"
        
        def download_m3u(url):
            """下载m3u文件的辅助函数"""
            print(f"开始下载: {url}")
            try:
                req = urllib.request.Request(url)
                req.add_header('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36')
                with urllib.request.urlopen(req, timeout=30) as response:
                    content = response.read().decode('utf-8')
                print("下载成功")
                return content
            except Exception as e:
                print(f"下载失败: {e}")
                return None
        
        def parse_m3u(content):
            """解析m3u文件的辅助函数"""
            lines = content.split('\n')
            channels = []
            current_channel = {}
            
            for line in lines:
                line = line.strip()
                if line.startswith('#EXTINF:'):
                    # 解析频道信息
                    current_channel = {'header': line}
                    # 提取group-title
                    group_match = re.search(r'group-title="([^"]*)"', line)
                    if group_match:
                        current_channel['group'] = group_match.group(1)
                    else:
                        current_channel['group'] = ''
                    # 提取频道名称
                    name_match = re.search(r',([^,]*)$', line)
                    if name_match:
                        current_channel['name'] = name_match.group(1)
                    else:
                        current_channel['name'] = ''
                    # 提取tvg-name
                    tvg_name_match = re.search(r'tvg-name="([^"]*)"', line)
                    if tvg_name_match:
                        current_channel['tvg_name'] = tvg_name_match.group(1)
                    else:
                        current_channel['tvg_name'] = ''
                elif line and not line.startswith('#') and current_channel:
                    current_channel['url'] = line
                    channels.append(current_channel.copy())
                    current_channel = {}
            
            return channels
        
        def filter_channels(channel_list):
            """过滤频道，去除包含'测试'和更新时间的频道"""
            filtered_channels = []
            removed_count = 0
            
            # 匹配更新时间的正则表达式模式
            # 匹配常见的日期时间格式，如: 2024-01-01, 2024/01/01, 2024.01.01, 20240101等
            time_patterns = [
                r'\d{4}-\d{1,2}-\d{1,2}',  # 2024-01-01
                r'\d{4}/\d{1,2}/\d{1,2}',  # 2024/01/01
                r'\d{4}\.\d{1,2}\.\d{1,2}',  # 2024.01.01
                r'\d{8}',  # 20240101
                r'\d{1,2}-\d{1,2}',  # 01-01
                r'\d{1,2}/\d{1,2}',  # 01/01
                r'\d{1,2}月\d{1,2}日',  # 1月1日
                r'\d{1,2}:\d{2}',  # 12:00
                r'\d{1,2}时\d{1,2}分',  # 12时00分
            ]
            
            for channel in channel_list:
                tvg_name = channel.get('tvg_name', '')
                name = channel.get('name', '')
                
                # 检查是否包含"测试"
                if '测试' in tvg_name or '测试' in name:
                    removed_count += 1
                    continue
                
                # 检查是否包含更新时间
                time_found = False
                for pattern in time_patterns:
                    if re.search(pattern, tvg_name) or re.search(pattern, name):
                        time_found = True
                        break
                
                if time_found:
                    removed_count += 1
                    continue
                
                # 通过过滤的频道
                filtered_channels.append(channel)
            
            print(f"过滤掉了 {removed_count} 个频道")
            return filtered_channels
        
        def update_group_title(header, old_group, new_group):
            """更新分组名称的辅助函数"""
            pattern = r'group-title="' + re.escape(old_group) + r'"'
            new_header = re.sub(pattern, f'group-title="{new_group}"', header)
            return new_header
        
        def add_group_title(header, new_group):
            """添加分组名称的辅助函数"""
            # 检查是否已有group-title
            if 'group-title=' in header:
                # 如果已有，则更新
                pattern = r'group-title="([^"]*)"'
                new_header = re.sub(pattern, f'group-title="{new_group}"', header)
            else:
                # 如果没有，则添加
                # 在频道名称之前添加group-title
                parts = header.split(',', 1)
                if len(parts) == 2:
                    new_header = parts[0] + f' group-title="{new_group}",' + parts[1]
                else:
                    new_header = header + f' group-title="{new_group}"'
            return new_header
        
        # 初始化所有频道列表
        live1_channels = []  # 央视咪咕 (从新链接提取)
        live2_channels = []  # 央视频道 (MCP)
        live3_channels = []  # 卫视咪咕 (从新链接提取)
        live4_channels = []  # 卫视频道 (MCP)
        live5_channels = []  # 影视频道
        live6_channels = []  # 体育频道
        
        # 下载并处理主m3u文件
        print("=== 处理主m3u文件 ===")
        main_content = download_m3u(main_m3u_url)
        if main_content:
            channels = parse_m3u(main_content)
            print(f"共解析到 {len(channels)} 个频道")
            
            print("开始分类处理频道...")
            for channel in channels:
                group = channel.get('group', '')
                name = channel.get('name', '')
                original_header = channel['header']
                
                # 1. 央视频道处理 - 只处理包含MCP的频道
                if group == '央视' and 'MCP' in name:
                    # 央视频道 (MCP)
                    new_header = update_group_title(original_header, group, '央视频道')
                    channel['header'] = new_header
                    live2_channels.append(channel)
                
                # 2. 卫视频道处理 - 只处理包含MCP的频道
                elif group == '卫视' and 'MCP' in name:
                    # 卫视频道 (MCP)
                    new_header = update_group_title(original_header, group, '卫视频道')
                    channel['header'] = new_header
                    live4_channels.append(channel)
                
                # 3. 其他、影视频道 -> 影视频道
                elif group in ['其他', '影视']:
                    new_header = update_group_title(original_header, group, '影视频道')
                    channel['header'] = new_header
                    live5_channels.append(channel)
                
                # 4. 体育频道 -> 体育频道
                elif group == '体育':
                    new_header = update_group_title(original_header, group, '体育频道')
                    channel['header'] = new_header
                    live6_channels.append(channel)
        else:
            print("主m3u文件下载失败，跳过主m3u文件的处理")
        
        # 下载并处理新增的migu_video链接
        print("\n=== 处理新增migu_video链接 ===")
        migu_video_content = download_m3u(migu_video_url)
        if migu_video_content:
            channels = parse_m3u(migu_video_content)
            print(f"migu_video链接: 解析到 {len(channels)} 个频道")
            
            # 提取分组为"央视"的频道
            cctv_channels = []
            # 提取分组为"卫视"的频道
            tv_channels = []
            
            for channel in channels:
                group = channel.get('group', '')
                original_header = channel['header']
                
                if group == '央视':
                    # 更新分组名称为"央视咪咕"
                    new_header = update_group_title(original_header, group, '央视咪咕')
                    channel['header'] = new_header
                    cctv_channels.append(channel)
                elif group == '卫视':
                    # 更新分组名称为"卫视咪咕"
                    new_header = update_group_title(original_header, group, '卫视咪咕')
                    channel['header'] = new_header
                    tv_channels.append(channel)
            
            live1_channels = cctv_channels
            live3_channels = tv_channels
            
            print(f"  央视咪咕分组: {len(live1_channels)} 个频道")
            print(f"  卫视咪咕分组: {len(live3_channels)} 个频道")
        else:
            print("migu_video链接下载失败，跳过处理")
        
        # 下载并处理额外的m3u文件
        print("\n=== 处理额外m3u文件 ===")
        extra_channels = {}
        
        for filename, url in extra_urls.items():
            content = download_m3u(url)
            if content:
                channels = parse_m3u(content)
                print(f"  {filename}: 解析到 {len(channels)} 个频道")
                
                # 重命名分组
                group_name_map = {
                    'huya.m3u': '虎牙轮播',
                    'douyu.m3u': '斗鱼轮播',
                    'yylunbo.m3u': 'Y Y 轮播'
                }
                
                updated_channels = []
                for channel in channels:
                    new_header = channel['header']
                    # 更新分组名称
                    group_match = re.search(r'group-title="([^"]*)"', new_header)
                    if group_match:
                        old_group = group_match.group(1)
                        new_header = update_group_title(new_header, old_group, group_name_map[filename])
                    
                    channel['header'] = new_header
                    updated_channels.append(channel)
                
                extra_channels[filename] = updated_channels
            else:
                print(f"  {filename}: 下载失败，跳过处理")
        
        # 下载并处理新增的URL
        print("\n=== 处理新增URL ===")
        additional_channels = {}
        
        # 处理每个新增URL
        for filename, url in additional_urls.items():
            content = download_m3u(url)
            if content:
                channels = parse_m3u(content)
                print(f"  {filename}: 解析到 {len(channels)} 个频道")
                
                # 设置分组名称
                group_name_map = {
                    'iqiyi.m3u': '爱奇频道',
                    'migu.m3u': '赛事咪咕',
                    'iqiyi1.m3u': '爱奇频道'  # iqiyi1也使用相同的分组名称
                }
                
                updated_channels = []
                for channel in channels:
                    new_header = channel['header']
                    
                    # 添加或更新分组名称
                    new_header = add_group_title(new_header, group_name_map[filename])
                    
                    channel['header'] = new_header
                    updated_channels.append(channel)
                
                additional_channels[filename] = updated_channels
                print(f"  {filename}: 已设置分组为 '{group_name_map[filename]}'")
            else:
                print(f"  {filename}: 下载失败，跳过处理")
        
        # 过滤所有分类的频道
        print("\n=== 开始过滤频道 ===")
        live1_channels = filter_channels(live1_channels)
        live2_channels = filter_channels(live2_channels)
        live3_channels = filter_channels(live3_channels)
        live4_channels = filter_channels(live4_channels)
        live5_channels = filter_channels(live5_channels)
        live6_channels = filter_channels(live6_channels)
        
        # 过滤额外的m3u文件
        for filename in extra_channels:
            extra_channels[filename] = filter_channels(extra_channels[filename])
        
        # 过滤新增的频道
        for filename in additional_channels:
            additional_channels[filename] = filter_channels(additional_channels[filename])
        
        # 写入各分类文件
        def write_m3u_file(filename, channel_list):
            if channel_list:  # 只有当频道列表不为空时才写入文件
                with open(filename, 'w', encoding='utf-8') as f:
                    f.write('#EXTM3U\n')
                    for channel in channel_list:
                        f.write(channel['header'] + '\n')
                        f.write(channel['url'] + '\n')
                print(f"  已写入: {filename} ({len(channel_list)} 个频道)")
                return True
            else:
                print(f"  跳过写入空文件: {filename}")
                return False
        
        print("\n开始写入分类文件...")
        written_files = []
        
        # 写入主分类文件并记录成功写入的文件
        if write_m3u_file('live1.m3u', live1_channels):
            written_files.append('live1.m3u')
        if write_m3u_file('live2.m3u', live2_channels):
            written_files.append('live2.m3u')
        if write_m3u_file('live3.m3u', live3_channels):
            written_files.append('live3.m3u')
        if write_m3u_file('live4.m3u', live4_channels):
            written_files.append('live4.m3u')
        if write_m3u_file('live5.m3u', live5_channels):
            written_files.append('live5.m3u')
        if write_m3u_file('live6.m3u', live6_channels):
            written_files.append('live6.m3u')
        
        # 写入额外的m3u文件
        for filename, channel_list in extra_channels.items():
            if write_m3u_file(filename, channel_list):
                written_files.append(filename)
        
        # 写入新增的m3u文件
        for filename, channel_list in additional_channels.items():
            if write_m3u_file(filename, channel_list):
                written_files.append(filename)
        
        # 合并文件（按指定顺序）
        print("开始合并文件...")
        with open('live.m3u', 'w', encoding='utf-8') as f:
            f.write('#EXTM3U\n')
            # 按指定顺序合并
            merge_order = [
                'live2.m3u', 'live4.m3u', 'live1.m3u', 'live3.m3u', 
                'migu.m3u', 'iqiyi.m3u', 'iqiyi1.m3u', 'live5.m3u', 'live6.m3u',  # 添加了iqiyi1.m3u
                'huya.m3u', 'douyu.m3u', 'yylunbo.m3u'
            ]
            
            for filename in merge_order:
                try:
                    if os.path.exists(filename):
                        with open(filename, 'r', encoding='utf-8') as src:
                            content = src.read()
                            # 跳过每个文件的EXTM3U头
                            lines = content.split('\n')[1:]
                            # 过滤空行
                            non_empty_lines = [line for line in lines if line.strip()]
                            if non_empty_lines:
                                f.write('\n'.join(non_empty_lines) + '\n')
                        print(f"  已合并: {filename}")
                    else:
                        print(f"  文件不存在，跳过合并: {filename}")
                except Exception as e:
                    print(f"  合并 {filename} 时出错: {e}")
        
        # 将live.m3u添加到已写入文件列表
        if os.path.exists('live.m3u'):
            written_files.append('live.m3u')
        
        # 将成功写入的文件列表保存到一个临时文件，供后续步骤使用
        with open('written_files.txt', 'w', encoding='utf-8') as f:
            for filename in written_files:
                f.write(filename + '\n')
        
        print("\n=== 处理完成 ===")
        print(f"成功生成的文件: {', '.join(written_files)}")
        EOF
    
    - name: Commit processed files
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # 只添加实际存在的文件
        if [ -f "written_files.txt" ]; then
          while IFS= read -r file; do
            if [ -f "$file" ]; then
              git add "$file"
              echo "已添加: $file"
            fi
          done < written_files.txt
        else
          # 如果written_files.txt不存在，则使用通配符添加可能存在的文件
          git add live*.m3u 2>/dev/null || true
          git add huya.m3u douyu.m3u yylunbo.m3u migu.m3u iqiyi.m3u iqiyi1.m3u 2>/dev/null || true
        fi
        
        # 删除临时文件
        if [ -f "written_files.txt" ]; then
          rm written_files.txt
        fi
        
        git diff --staged --quiet || git commit -m "自动更新分类后的播放列表 [skip ci]"
        git push
